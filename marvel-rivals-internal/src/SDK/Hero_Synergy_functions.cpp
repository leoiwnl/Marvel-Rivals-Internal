#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_Synergy

#include "Basic.hpp"

#include "Hero_Synergy_classes.hpp"
#include "Hero_Synergy_parameters.hpp"


namespace SDK
{

// Function Hero_Synergy.MarvelBackTrackAbility.DelayStartRecord
// (Final, Native, Public)
// Parameters:
// bool                                    bSetDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::DelayStartRecord(bool bSetDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "DelayStartRecord");

	Params::MarvelBackTrackAbility_DelayStartRecord Parms{};

	Parms.bSetDelay = bSetDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.IsHoldMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMarvelBackTrackAbility::IsHoldMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "IsHoldMode");

	Params::MarvelBackTrackAbility_IsHoldMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.MarvelBackTrackAbility.MulticastInterrupt
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UMarvelBackTrackAbility::MulticastInterrupt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "MulticastInterrupt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnCharacterMovementPreUpdated
// (Final, Native, Public)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnCharacterMovementPreUpdated(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnCharacterMovementPreUpdated");

	Params::MarvelBackTrackAbility_OnCharacterMovementPreUpdated Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnCharTranslatedByPortal
// (Final, Native, Public)
// Parameters:
// class APortalViewActor*                 InPortalActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnCharTranslatedByPortal(class APortalViewActor* InPortalActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnCharTranslatedByPortal");

	Params::MarvelBackTrackAbility_OnCharTranslatedByPortal Parms{};

	Parms.InPortalActor = InPortalActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnClientAckMoveWithStamp
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// float                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnClientAckMoveWithStamp(const float Timestamp, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnClientAckMoveWithStamp");

	Params::MarvelBackTrackAbility_OnClientAckMoveWithStamp Parms{};

	Parms.Timestamp = Timestamp;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnLivingStateChanged
// (Final, Native, Public)
// Parameters:
// EPlayerLivingState                      LivingState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnLivingStateChanged(EPlayerLivingState LivingState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnLivingStateChanged");

	Params::MarvelBackTrackAbility_OnLivingStateChanged Parms{};

	Parms.LivingState = LivingState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnLongPressRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeHeld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnLongPressRelease(float TimeHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnLongPressRelease");

	Params::MarvelBackTrackAbility_OnLongPressRelease Parms{};

	Parms.TimeHeld = TimeHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnLongPressTimeOverMaxHoldTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeHeld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnLongPressTimeOverMaxHoldTime(float TimeHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnLongPressTimeOverMaxHoldTime");

	Params::MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime Parms{};

	Parms.TimeHeld = TimeHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnServerHandleClientMoveWithStamp
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// float                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnServerHandleClientMoveWithStamp(const float Timestamp, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnServerHandleClientMoveWithStamp");

	Params::MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp Parms{};

	Parms.Timestamp = Timestamp;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.RecordState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::RecordState(const float Timestamp, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "RecordState");

	Params::MarvelBackTrackAbility_RecordState Parms{};

	Parms.Timestamp = Timestamp;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.ServerCheckClientLocValid
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          InTargetLoc                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStrictCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMarvelBackTrackAbility::ServerCheckClientLocValid(const struct FVector& InTargetLoc, bool bStrictCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "ServerCheckClientLocValid");

	Params::MarvelBackTrackAbility_ServerCheckClientLocValid Parms{};

	Parms.InTargetLoc = std::move(InTargetLoc);
	Parms.bStrictCheck = bStrictCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.MarvelBackTrackAbility.ServerInterrupt
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FVector                          InClientLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::ServerInterrupt(const struct FVector& InClientLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "ServerInterrupt");

	Params::MarvelBackTrackAbility_ServerInterrupt Parms{};

	Parms.InClientLocation = std::move(InClientLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StartBackTrack
// (Final, Native, Public, BlueprintCallable)

void UMarvelBackTrackAbility::StartBackTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StartBackTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StartRecordState
// (Final, Native, Public, BlueprintCallable)

void UMarvelBackTrackAbility::StartRecordState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StartRecordState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StopBackTrack
// (Final, Native, Public, BlueprintCallable)

void UMarvelBackTrackAbility::StopBackTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StopBackTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StopRecordState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClearData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::StopRecordState(bool bClearData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StopRecordState");

	Params::MarvelBackTrackAbility_StopRecordState Parms{};

	Parms.bClearData = bClearData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.SafeMoveTo
// (Final, Native, Public, HasOutParams, HasDefaults, Const)
// Parameters:
// struct FVector                          TargetLoc                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMarvelBackTrackAbility::SafeMoveTo(const struct FVector& TargetLoc, struct FHitResult* OutHit, bool bSweep) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "SafeMoveTo");

	Params::MarvelBackTrackAbility_SafeMoveTo Parms{};

	Parms.TargetLoc = std::move(TargetLoc);
	Parms.bSweep = bSweep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Hero_Synergy.TraceComponent_100009.OnPreOutTraceResults
// (Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTraceComponent_100009::OnPreOutTraceResults(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceComponent_100009", "OnPreOutTraceResults");

	Params::TraceComponent_100009_OnPreOutTraceResults Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnAbilityActivate
// (Final, Native, Public)
// Parameters:
// int32                                   AbilityID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnAbilityActivate(int32 AbilityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnAbilityActivate");

	Params::BuffManagerAbility_100009_OnAbilityActivate Parms{};

	Parms.AbilityID = AbilityID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnAbilityEnded
// (Final, Native, Public)
// Parameters:
// int32                                   AbilityID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnAbilityEnded(int32 AbilityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnAbilityEnded");

	Params::BuffManagerAbility_100009_OnAbilityEnded Parms{};

	Parms.AbilityID = AbilityID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnBuffExecuted
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecStackHandle   EffectSpecHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnBuffExecuted(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnBuffExecuted");

	Params::BuffManagerAbility_100009_OnBuffExecuted Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectSpecHandle = std::move(EffectSpecHandle);
	Parms.EffectHandle = std::move(EffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnBuffRemoved
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayEffectSpec              RemovedSpec                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bPrematureRemoval                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnBuffRemoved(const struct FGameplayEffectSpec& RemovedSpec, bool bPrematureRemoval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnBuffRemoved");

	Params::BuffManagerAbility_100009_OnBuffRemoved Parms{};

	Parms.RemovedSpec = std::move(RemovedSpec);
	Parms.bPrematureRemoval = bPrematureRemoval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnOwnerCollide
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnOwnerCollide(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnOwnerCollide");

	Params::BuffManagerAbility_100009_OnOwnerCollide Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnOwnerTakeDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           InSourceAvatar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetAvatar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeModifierHandle         ModifierParameterHandle                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnOwnerTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnOwnerTakeDamage");

	Params::BuffManagerAbility_100009_OnOwnerTakeDamage Parms{};

	Parms.InSourceAvatar = InSourceAvatar;
	Parms.InTargetAvatar = InTargetAvatar;
	Parms.ModifierParameterHandle = std::move(ModifierParameterHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.RemoveBuffFromSelf
// (Final, Native, Public, BlueprintCallable)

void UBuffManagerAbility_100009::RemoveBuffFromSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "RemoveBuffFromSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.RestoreBuffToSelfWithDelay
// (Final, Native, Public, BlueprintCallable)

void UBuffManagerAbility_100009::RestoreBuffToSelfWithDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "RestoreBuffToSelfWithDelay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.AddWavingData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbility_100015::AddWavingData(const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "AddWavingData");

	Params::Ability_100015_AddWavingData Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.BindCancelRideInput
// (Final, Native, Protected, BlueprintCallable)

void UAbility_100015::BindCancelRideInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "BindCancelRideInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.CancelRelevantSynergyAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNormalEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::CancelRelevantSynergyAbility(bool bNormalEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "CancelRelevantSynergyAbility");

	Params::Ability_100015_CancelRelevantSynergyAbility Parms{};

	Parms.bNormalEnd = bNormalEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.ClearWavingHoldTimer
// (Final, Native, Public, BlueprintCallable)

void UAbility_100015::ClearWavingHoldTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "ClearWavingHoldTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.CustomCommitSynergyCoolDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNormalEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::CustomCommitSynergyCoolDown(bool bNormalEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "CustomCommitSynergyCoolDown");

	Params::Ability_100015_CustomCommitSynergyCoolDown Parms{};

	Parms.bNormalEnd = bNormalEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.GetDashPortalSegments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPortalSegments                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPortalSegments UAbility_100015::GetDashPortalSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "GetDashPortalSegments");

	Params::Ability_100015_GetDashPortalSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.GetRelevantSynergyAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMarvelBaseCharacter*             InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbility_100015*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbility_100015* UAbility_100015::GetRelevantSynergyAbility(class AMarvelBaseCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "GetRelevantSynergyAbility");

	Params::Ability_100015_GetRelevantSynergyAbility Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.HasActiveBond
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::HasActiveBond()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "HasActiveBond");

	Params::Ability_100015_HasActiveBond Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.IsAbilityNormalEnd
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::IsAbilityNormalEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "IsAbilityNormalEnd");

	Params::Ability_100015_IsAbilityNormalEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.K2_OnStartWaving
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnStartWaving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnStartWaving");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.K2_OnWavingConfirmed
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnWavingConfirmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnWavingConfirmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.K2_OnWavingTimeOut
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnWavingTimeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnWavingTimeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnCoopAbilityTickStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bShouldAbilityTick                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::OnCoopAbilityTickStateChanged(bool bShouldAbilityTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnCoopAbilityTickStateChanged");

	Params::Ability_100015_OnCoopAbilityTickStateChanged Parms{};

	Parms.bShouldAbilityTick = bShouldAbilityTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnOwnerGameplayTagUpdate
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTagExists                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::OnOwnerGameplayTagUpdate(const struct FGameplayTag& InTag, bool bTagExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnOwnerGameplayTagUpdate");

	Params::Ability_100015_OnOwnerGameplayTagUpdate Parms{};

	Parms.InTag = std::move(InTag);
	Parms.bTagExists = bTagExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRep_ConfirmedCharacter
// (Final, Native, Protected)

void UAbility_100015::OnRep_ConfirmedCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRep_ConfirmedCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRep_CurrentWavingState
// (Final, Native, Protected)

void UAbility_100015::OnRep_CurrentWavingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRep_CurrentWavingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRep_WavingData
// (Final, Native, Protected)

void UAbility_100015::OnRep_WavingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRep_WavingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRideCancel
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// float                                   StateIntervalTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::OnRideCancel(float StateIntervalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRideCancel");

	Params::Ability_100015_OnRideCancel Parms{};

	Parms.StateIntervalTime = StateIntervalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.Python_OnRideCancel
// (Event, Protected, BlueprintEvent)

void UAbility_100015::Python_OnRideCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "Python_OnRideCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Hero_Synergy.Ability_100015.SetCurrentWavingCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::SetCurrentWavingCharacter(const class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "SetCurrentWavingCharacter");

	Params::Ability_100015_SetCurrentWavingCharacter Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.SetWavingConfirmedByCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMarvelBaseCharacter*             InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::SetWavingConfirmedByCharacter(class AMarvelBaseCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "SetWavingConfirmedByCharacter");

	Params::Ability_100015_SetWavingConfirmedByCharacter Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.SetWavingState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESynergyWavingState                     InNewState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::SetWavingState(ESynergyWavingState InNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "SetWavingState");

	Params::Ability_100015_SetWavingState Parms{};

	Parms.InNewState = InNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.GetWavingState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESynergyWavingState                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESynergyWavingState UAbility_100015::GetWavingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "GetWavingState");

	Params::Ability_100015_GetWavingState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100016.BroadcastThrowSplineHudEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100016::BroadcastThrowSplineHudEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "BroadcastThrowSplineHudEnabled");

	Params::Ability_100016_BroadcastThrowSplineHudEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100016.OnRep_ThrowCharacter
// (Final, Native, Public)

void UAbility_100016::OnRep_ThrowCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "OnRep_ThrowCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100016.OnThrowCharacterCoopRideStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsRiding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMarvelBaseCharacter*             RideCharacter                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100016::OnThrowCharacterCoopRideStateChanged(bool bIsRiding, class AMarvelBaseCharacter* RideCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "OnThrowCharacterCoopRideStateChanged");

	Params::Ability_100016_OnThrowCharacterCoopRideStateChanged Parms{};

	Parms.bIsRiding = bIsRiding;
	Parms.RideCharacter = RideCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100016.PredictThrowDataWhenPressed
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PredictVelocity                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PredictionPath                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   MaxFallSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxJumpHeightDown                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100016::PredictThrowDataWhenPressed(const struct FVector& PredictVelocity, TArray<struct FVector>* PredictionPath, float MaxFallSeconds, float MaxJumpHeightDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "PredictThrowDataWhenPressed");

	Params::Ability_100016_PredictThrowDataWhenPressed Parms{};

	Parms.PredictVelocity = std::move(PredictVelocity);
	Parms.MaxFallSeconds = MaxFallSeconds;
	Parms.MaxJumpHeightDown = MaxJumpHeightDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PredictionPath != nullptr)
		*PredictionPath = std::move(Parms.PredictionPath);
}


// Function Hero_Synergy.Ability_100016.PredictThrowVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   PredictSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoteRole                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbility_100016::PredictThrowVelocity(float PredictSpeed, bool bRemoteRole, const struct FRotator& InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "PredictThrowVelocity");

	Params::Ability_100016_PredictThrowVelocity Parms{};

	Parms.PredictSpeed = PredictSpeed;
	Parms.bRemoteRole = bRemoteRole;
	Parms.InRotator = std::move(InRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Cue_Ability_Loop_100016.OnOwnerAbilityThrowSplineHudEnabledChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACue_Ability_Loop_100016::OnOwnerAbilityThrowSplineHudEnabledChanged(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_100016", "OnOwnerAbilityThrowSplineHudEnabledChanged");

	Params::Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Cue_Ability_Loop_100016.OnPressRelease
// (Final, Native, Public)
// Parameters:
// float                                   TimeWaited                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACue_Ability_Loop_100016::OnPressRelease(float TimeWaited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_100016", "OnPressRelease");

	Params::Cue_Ability_Loop_100016_OnPressRelease Parms{};

	Parms.TimeWaited = TimeWaited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Cue_Ability_Loop_100016.OnPressTimeMin
// (Final, Native, Public)
// Parameters:
// float                                   TimeWaited                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACue_Ability_Loop_100016::OnPressTimeMin(float TimeWaited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_100016", "OnPressTimeMin");

	Params::Cue_Ability_Loop_100016_OnPressTimeMin Parms{};

	Parms.TimeWaited = TimeWaited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

